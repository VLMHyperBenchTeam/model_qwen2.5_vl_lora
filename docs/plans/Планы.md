Read file: Планы.md

Ниже – краткая оценка всех пунктов из «Планы.md».
Для каждого пункта указал (1) пользу, (2) сложность внедрения и (3) приоритет – где «★» = низкий, «★★» = средний, «★★★» = высокий.

────────────────────────────────────────────────────────
I. Общее по репозиторию
────────────────────────────────────────────────────────
3. Единый helper `resolve_cache_and_device`
• Польза: снимает дублирование, облегчает запуск на CPU/GPU.
• Сложность: ★ (один модуль + правка вызовов).
• Приоритет: ★★★ – «быстрая победа» с большим эффектом.

4. Централизованная загрузка промптов
• Польза: избавляет от ручного копирования кода, проще менять формат.
• Сложность: ★.
• Приоритет: ★★ – стоит добить сразу после п. 3.

5. Универсальный `run_task.py` вместо трёх скриптов
• Польза: единая CLI-точка, меньше копий кода.
• Сложность: ★★–★★★ (нужно продумать интерфейс и обратную совместимость).
• Приоритет: ★★ – важно, но можно делать после стабилизации API.

6. Модульные тесты + CI
• Польза: раннее обнаружение регрессий, особенно после крупного рефакторинга.
• Сложность: ★★ (тест-каркасы простые, но надо настроить GitHub Actions или аналог).
• Приоритет: ★★★ – имеет смысл включить в любой значимый MR.

7. Реорганизация пакетов в `src/{core,models,tasks}`
• Польза: кристально понятная структура, легко публиковать.
• Сложность: ★★★ (затронет импорты, пути, доку).
• Приоритет: ★ – стратегическая цель; лучше планировать после стабилизации текущих интерфейсов.

8. Обновление документации
• Польза: снижает порог входа.
• Сложность: ★.
• Приоритет: ★★ – делать параллельно с изменениями, иначе док станет неактуальным.

────────────────────────────────────────────────────────
II. Рефакторинг `check_classifiication.py`
────────────────────────────────────────────────────────
1. Использовать фасад `bench_utils.model_utils` вместо прямого импорта `ModelFactory`
• Польза: разрываем сильную связь, упрощаем дальнейшие правки.
• Сложность: ★.
• Приоритет: ★★★ – внедрить сразу.

2. `initialize_model`/`initialize_qwen_model` вместо `ModelFactory.initialize_model`
• Польза: та же, что и п. 1; код короче.
• Сложность: ★.
• Приоритет: ★★★.

3. Свести импорты пакетов к одному блоку `bench_utils`
• Польза: читаемость, единая точка входа.
• Сложность: ★.
• Приоритет: ★★.

4. Функция `prepare_prompt` в util-ах
• Польза: убирает дублирование между скриптами.
• Сложность: ★.
• Приоритет: ★★.

5. Переименовать файл в `check_classification.py`, оставить тонкий shim
• Польза: исправление опечатки, лучше автодополнение.
• Сложность: ★ (но придётся добавить `DeprecationWarning`).
• Приоритет: ★.

6. Вынести вспомогательные функции в `bench_utils/image_classification.py`
• Польза: переиспользование и тестирование.
• Сложность: ★★.
• Приоритет: ★★.

7. CLI через `argparse`
• Польза: гибкая отладка, интеграция в пайплайны.
• Сложность: ★★.
• Приоритет: ★.

8. Dataclass/Pydantic-валидация конфига
• Польза: ловим ошибки рантайма на этапе загрузки.
• Сложность: ★–★★ (зависит от выбранного инструмента).
• Приоритет: ★.

9. Переход на `logging`
• Польза: управляемый вывод, уровни логов.
• Сложность: ★.
• Приоритет: ★★ (можно совместить с п. 7).

10. Юнит-тесты для скрипта
• Польза: гарантия стабильности после рефакторинга.
• Сложность: ★★.
• Приоритет: ★★.

────────────────────────────────────────────────────────
Резюме по действиям «сейчас» (Sprint 1)
────────────────────────────────────────────────────────
1) Реализовать helper `resolve_cache_and_device` и заменить вызовы (I-3).
2) Перевести `check_classifiication.py` на `bench_utils.model_utils` + переименовать файл (II-1,2,5).
3) Добавить `prepare_prompt` и убрать дублирование (II-4).
4) Включить модульные тесты для `initialize_model` и основного скрипта (I-6, II-10).

Эти шаги требуют минимальных усилий, но дадут самое большое снижение технического долга. Остальные предложения логично планировать после того, как базовая архитектура стабилизируется.

# Обновленные планы

Ниже ― обновлённая дорожная-карта, уже с учётом требования «направление зависимостей только вниз»:

```
run-/check-скрипты  ─►  bench_utils  ─►  model_interface  ─►  (конкретные модели)
```

`model_interface` НИКОГДА не должен импортировать `bench_utils`, поэтому любые функции, которые нужны обоим слоям, размещаем в **model_interface** или в «чистых» внешних библиотеках.

────────────────────────────────────────────────────────
A. Слой model_interface  (ядро, высокая абстракция)
────────────────────────────────────────────────────────
1.  helpers.resolve_cache_and_device   ★★★
    • Новый модуль `model_interface.helpers`
    • Функция:
      ```python
      def resolve_cache_and_device(cfg: ModelConfig) -> dict: ...
      ```
    • Вызывается из `ModelFactory.initialize_model()` и из конструкторов конкретных моделей.

2.  prompt_utils.load_prompt / prepare_prompt   ★★
    • Перенести (или оставить) `load_prompt` сюда же.
    • Добавить `prepare_prompt(path, classes_dict)` – формирует конечный prompt-строку.
    • bench_utils и скрипты будут импортировать:
      ```python
      from model_interface.prompt_utils import load_prompt, prepare_prompt
      ```

3.  Публичный API (__all__)
    • Оставить «реэкспорт»:
      ```python
      from .model_factory import ModelFactory, initialize_model, initialize_qwen_model
      from .prompt_utils import load_prompt, prepare_prompt
      __all__ = ["ModelFactory", "initialize_model", ...]
      ```

4.  Тесты ядра   ★★
    • `tests/test_model_interface_factory.py`
    • Проверяем регистрацию, инициализацию, helper-ы.

────────────────────────────────────────────────────────
B. Слой bench_utils  (утилиты для бенчей и скриптов)
────────────────────────────────────────────────────────
1.  model_utils.py   ★★★
    • Превращается в «тонкую обёртку»:
      ```python
      from model_interface import (
          initialize_model,
          initialize_qwen_model,
          load_prompt,
          prepare_prompt,
          ModelFactory,
      )
      __all__ = [... то же ...]
      ```
    • Никакой новой логики внутри, только «re-export».
      Это позволяет менять ядро, не трогая скрипты.

2.  metrics.py / utils.py (уже есть)
    • Обособлены, не импортируют `model_interface` – всё ок.

3.  image_classification.py   ★★
    • Сюда выносим вспомогательные функции (`get_image_paths`, `get_prediction`, `calculate_and_save_metrics`).
    • Эти функции используют только публичный API из `bench_utils` + `model_interface`, не наоборот.

4.  Тесты утилит   ★
    • Проверяем корректность метрик, correct handling of None, etc.

────────────────────────────────────────────────────────
C. Скрипты верхнего уровня  (run_*, check_*)
────────────────────────────────────────────────────────
1.  Переименование `check_classifiication.py` → `check_classification.py`   ★
    • Старый файл оставляем-shim с:
      ```python
      import warnings, import check_classification as _new
      warnings.warn("Файл переименован...", DeprecationWarning)
      ```

2.  Обновить импорты   ★★★
    ```
    from bench_utils.metrics import calculate_classification_metrics
    from bench_utils.model_utils import (
        initialize_model,
        load_prompt,
        prepare_prompt,
    )
    from bench_utils.utils import get_run_id, load_config, save_results_to_csv
    ```

3.  Использовать prepare_prompt   ★★
    ```python
    prompt = prepare_prompt(prompt_path, document_classes)
    ```

4.  (Опционально) argparse-CLI + logging   ★★
    • Не меняет зависимостей, можно внедрять постепенно.

────────────────────────────────────────────────────────
D. Контроль направления импортов  (CI)
────────────────────────────────────────────────────────
Добавить шаг в CI:

```bash
# model_interface не должен тянуть bench_utils
grep -R "from bench_utils" packages/model_interface && exit 1
```

────────────────────────────────────────────────────────
Приоритет на ближайший спринт
────────────────────────────────────────────────────────
1) Реализовать `model_interface.helpers.resolve_cache_and_device`.
2) Вынести/добавить `model_interface.prompt_utils.prepare_prompt`.
3) Превратить `bench_utils.model_utils` в чистый «re-export».
4) Переименовать скрипт, обновить импорты, применить `prepare_prompt`.
5) Пройтись grep-проверкой, убедившись, что model_interface ничего не импортирует из bench_utils.

Так мы закрепим правильную иерархию зависимостей и упростим дальнейшую эволюцию проекта.



