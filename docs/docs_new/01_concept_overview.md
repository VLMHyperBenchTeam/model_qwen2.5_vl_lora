# Концепция процесса разработки

## 1. Микропакетная архитектура

Каждый компонент оформлен как самостоятельный Python-пакет, который:

- управляет зависимостями через `uv`;
- может быть установлен стандартными инструментами — `pip`, `poetry`, `uv install`;
- собирается с помощью `hatchling` build-backend.

## 2. Разделение репозиториев

Каждый python-пакет расположен в отдельном репозитории на GitHub.

Это обеспечивает:

- собственную историю коммитов, теги версий и ветки;
- изоляцию CI/CD-пайплайнов каждого пакета;
- возможность открывать Pull Request-ы независимо от основного проекта.

В корневом репозитории пакеты подключены как `git submodule`, что позволяет:

- выполнять привычные git-операции (`checkout`, `pull`, `log`, `tag`) прямо из корня проекта;
- фиксировать зависимость пакета на конкретный коммит;
- легко обновлять пакет до новой версии одной командой `git submodule update --remote`.

`submodule` выступает в роли «прокси» к чужому репозиторию: код пакета не содержится в истории основного проекта, но всегда под рукой.

## 3. Разные режимы разработки

В процессе разработки ML-проектов возникают разные потребности:

### Активная разработка
- Нужна возможность быстро вносить изменения в код python-пакета и сразу видеть результат
- Удобно иметь все пакеты под рукой в editable-режиме
- Требуются dev-зависимости для тестирования и отладки

### Предрелизное тестирование
- Необходимо проверить работоспособность на «почти финальных» версиях
- Важно зафиксировать версии для воспроизводимого тестирования
- Окружение должно быть максимально близко к продакшену

### Продакшен и CI/CD
- Критически важна воспроизводимость сборки
- Нужны только стабильные, протестированные версии
- Минимальный набор зависимостей без dev-инструментов
- Быстрая сборка без лишних компонентов

## 4. Как мы решаем задачу разделения с помощью uv

Рабочее пространство (`workspace`) в **uv 0.7** использует **единый lock-файл** (`uv.lock`) и **одну виртуальную среду** `.venv` для всех компонентов.

Чтобы разделять окружения *dev*, *staging* и *prod*, держим для каждого собственный `pyproject.toml`:

- `pyproject.toml` — *dev*-сборка;
- `staging/pyproject.toml` — *staging*-сборка;
- `prod/pyproject.toml` — *prod*-сборка.

### dev — активная разработка

- пакеты подключаются локально в режиме *editable*;
- любые изменения в исходном коде сразу видны в окружении;
- включены все dev-зависимости для тестирования и отладки.

### staging — предрелизное тестирование

- фиксирует зависимости на dev-теги, готовые к ручному тестированию;
- окружение максимально близко к *prod*, но допускает полировку изменений;
- позволяет выявить проблемы до финального релиза.

### prod — подготовка к релизу / CI

- окружение собирается из опубликованных версий, отмеченных `git tag`;
- пакеты устанавливаются так же, как из PyPI, и не предполагают изменения кода;
- минимальный набор зависимостей для оптимальной производительности.

## 5. Релизный процесс

Для ускорения процесса релиза разработан CLI-инструмент **`release_tool`** ([ссылка](https://github.com/VLMHyperBenchTeam/release_tool)), который:

- автоматически формирует коммиты, теги и GitHub-релизы;
- собирает *diff-файлы*, пригодные для генерации описаний релиза LLM;
- поддерживает режим `--dry-run` для безопасной проверки;
- использует `tomlkit` для точного редактирования TOML-файлов.

## 6. Автоматическая сборка Docker-образа

Для сборки Docker-образов из uv-окружений создан `docker/Dockerfile-uv`:

### Основные возможности
- **Универсальность**: один Dockerfile для dev и prod окружений
- **Гибкость**: CUDA-версия и варианты базового образа задаются через `--build-arg`
- **Оптимизация**: многоступенчатая сборка с кэшированием wheel-файлов
- **Специализация для ML**: автоматическая сборка `flash-attn` под нужную версию CUDA

### Архитектура сборки
1. **Базовый слой**: системные зависимости и бинарный файл `uv`
2. **Зависимости**: отдельные слои для dev и prod окружений
3. **Wheel-сборка**: компиляция `flash-attn` с кэшированием результата
4. **Финальные образы**: минимальные runtime-слои для dev и prod

### Основная идея
1. Многоступенчатая сборка (`base` → `deps` → `wheel` → `runtime`)
2. На этапе `deps` — `uv sync --locked` для воспроизводимости
3. В финальный слой копируются лишь скомпилированные зависимости и исходный код
4. Поддержка разных CUDA-версий через build-аргументы

Пример сборки prod-образа:
```bash
docker build \
  -f docker/Dockerfile-uv \
  --target prod \
  -t myproj:prod-cu124 \
  --build-arg CUDA_VERSION=12.4.1 \
  .
```
