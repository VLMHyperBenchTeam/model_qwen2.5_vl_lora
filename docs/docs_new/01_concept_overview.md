# Концепция процесса разработки

## 1. Микропакетная архитектура

Каждый компонент оформлен как самостоятельный Python-пакет, который:

- управляет зависимостями через `uv`;
- может быть установлен стандартными инструментами — `pip`, `poetry`, `uv install`;
- собирается с помощью `hatchling` build-backend.

## 2. Разделение репозиториев

Каждый python-пакет расположен в отдельном репозитории на GitHub.

Это обеспечивает:

- собственную историю коммитов, теги версий и ветки;
- изоляцию CI/CD-пайплайнов каждого пакета;
- возможность открывать Pull Request-ы независимо от основного проекта.

В корневом репозитории пакеты подключены как `git submodule`, что позволяет:

- выполнять привычные git-операции (`checkout`, `pull`, `log`, `tag`) прямо из корня проекта;
- фиксировать зависимость пакета на конкретный коммит;
- легко обновлять пакет до новой версии одной командой `git submodule update --remote`.

`submodule` выступает в роли «прокси» к чужому репозиторию: код пакета не содержится в истории основного проекта, но всегда под рукой.

## 3. Разные режимы разработки

В процессе разработки ML-проектов возникают разные потребности:

### Активная разработка
- Нужна возможность быстро вносить изменения в код python-пакета и сразу видеть результат
- Удобно иметь все пакеты под рукой в editable-режиме
- Требуются dev-зависимости для тестирования и отладки

### Предрелизное тестирование
- Необходимо проверить работоспособность на «почти финальных» версиях
- Важно зафиксировать версии для воспроизводимого тестирования
- Окружение должно быть максимально близко к продакшену

### Продакшен и CI/CD
- Критически важна воспроизводимость сборки
- Нужны только стабильные, протестированные версии
- Минимальный набор зависимостей без dev-инструментов
- Быстрая сборка без лишних компонентов

## 4. Как мы решаем задачу разделения с помощью uv

Рабочее пространство (`workspace`) в **uv 0.7** использует **единый lock-файл** (`uv.lock`) и **одну виртуальную среду** `.venv` для всех компонентов.

### Архитектура конфигураций

Для разделения окружений используем **три отдельных** `pyproject.toml`:

```
project/
├── pyproject.toml          # dev-конфигурация
├── staging/
│   └── pyproject.toml      # staging-конфигурация
├── prod/
│   └── pyproject.toml      # prod-конфигурация
└── packages/               # локальные пакеты
    ├── package1/
    └── package2/
```

### Различия в конфигурациях

| Аспект | dev | staging | prod |
|--------|-----|---------|------|
| **Источник пакетов** | `workspace = true` (локальные) | `git` + `tag = "v1.0.0.dev0"` | `git` + `tag = "v1.0.0"` |
| **Режим установки** | editable | обычный | обычный |
| **Зависимости** | включены dev-группы | только runtime | только runtime |
| **Lock-файл** | `uv.lock` | `staging/uv.lock` | `prod/uv.lock` |

## 5. Релизный процесс

Для ускорения процесса релиза разработан CLI-инструмент **`release_tool`** ([ссылка](https://github.com/VLMHyperBenchTeam/release_tool)), который:

- автоматически формирует коммиты, теги и GitHub-релизы;
- собирает *diff-файлы*, пригодные для генерации описаний релиза LLM;
- поддерживает режим `--dry-run` для безопасной проверки;
- использует `tomlkit` для точного редактирования TOML-файлов.

## 6. Автоматическая сборка Docker-образа

Для сборки Docker-образов из uv-окружений создан `docker/Dockerfile-uv`:

### Основные возможности
- **Универсальность**: один Dockerfile для dev и prod окружений
- **Гибкость**: CUDA-версия и варианты базового образа задаются через `--build-arg`
- **Оптимизация**: многоступенчатая сборка с кэшированием wheel-файлов
- **Специализация для ML**: автоматическая сборка `flash-attn` под нужную версию CUDA

### Архитектура сборки
1. **Базовый слой**: системные зависимости и бинарный файл `uv`
2. **Зависимости**: отдельные слои для dev и prod окружений
3. **Wheel-сборка**: компиляция `flash-attn` с кэшированием результата
4. **Финальные образы**: минимальные runtime-слои для dev и prod

### Основная идея
1. Многоступенчатая сборка (`base` → `deps` → `wheel` → `runtime`)
2. На этапе `deps` — `uv sync --locked` для воспроизводимости
3. В финальный слой копируются лишь скомпилированные зависимости и исходный код
4. Поддержка разных CUDA-версий через build-аргументы
