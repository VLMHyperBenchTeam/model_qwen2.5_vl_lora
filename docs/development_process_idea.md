# Концепция процесса разработки

## 1. Микропакетная архитектура

Каждый компонент оформлен как самостоятельный Python-пакет, который:

- управляет зависимостями через `uv`;
- может быть установлен стандартными инструментами — `pip`, `poetry`, `uv install`;
- собирается с помощью `hatchling` build-backend.

## 2. Два режима работы

`uv workspaces` автоматически создаёт и изолирует два независимых виртуальных окружения, позволяя переключаться между ними одной командой.

### dev — активная разработка

- пакеты подключаются локально в режиме *editable*;
- любые изменения в исходном коде сразу видны в окружении.

### prod — подготовка к релизу / CI

- окружение собирается из опубликованных версий, отмеченных `git tag`;
- пакеты устанавливаются так же, как из PyPI, и не предполагают изменения кода.

## 3. Разделение репозиториев

Каждый пакет расположен в отдельном репозитории на GitHub.

Это обеспечивает:

- собственную историю коммитов, теги версий и ветки;
- изоляцию CI/CD-пайплайнов каждого пакета;
- возможность открывать Pull Request-ы независимо от основного проекта.

В корневом репозитории пакеты подключены как `git submodule`, что позволяет:

- выполнять привычные git-операции (`checkout`, `pull`, `log`, `tag`) прямо из корня проекта;
- фиксировать зависимость пакета на конкретный коммит;
- легко обновлять пакет до новой версии одной командой `git submodule update --remote`.

`submodule` выступает в роли «прокси» к чужому репозиторию: код пакета не содержится в истории основного проекта, но всегда под рукой.

## 4. Релизный процесс

Полный цикл релиза в связке `uv workspaces` + `git submodules` занимает ~30 минут и требует множества однотипных действий.

Чтобы сократить рутину, был создан CLI-инструмент **`release_tool`**, который:

- автоматизирует создание коммитов, тегов и GitHub-релизов, оставляя при этом возможность оформить Pull Request вручную;
- формирует *diff-файлы*, которые можно передать LLM для генерации:
  - commit-сообщений в стиле **Conventional Commits**;
  - подробного **markdown-описания** релиза;
- поддерживает режим `--dry-run`, позволяющий проверить все шаги без изменения репозитория.

В итоге многошаговый процесс сводится к нескольким CLI-командам, а качество сопроводительной документации повышается за счёт генерации LLM.

## 5. Автоматическая сборка Docker-образа

В перспективе хотелось бы, чтобы после переключения проекта в режим `prod` одной CLI-командой собирался оптимизированный Docker-образ.

`uv` уже умеет фиксировать версии пакетов, поэтому задача сводится к тому, чтобы на базе файла **prod/pyproject.toml**:

1. сформировать финальное окружение;
1. упаковать его в контейнер.

### Зачем это нужно

- гарантированное воспроизведение окружения на любых серверах;
- быстрый деплой через `docker pull && docker run`;
- минимальные слои за счёт кэшируемых этапов (base-образ → deps-layer → app-layer).

### План реализации

1. Использовать многоступенчатую сборку (*multi-stage build*) для разделения слоёв: `builder`, `deps`, `runtime`.
1. На этапе `deps` выполнить `uv pip sync --python /path/to/python` с теми же версионированными зависимостями, что и в `prod`-режиме.
1. Копировать только скомпилированные зависимости и исходный код приложения в финальный `runtime`-слой, оставляя кеш пакетов вне итогового образа.
1. Автоматизировать процесс в новом скрипте **`release_tool-stage7`** (расширение существующего пайплайна), который:
   - формирует `Dockerfile` по шаблону,
   - запускает `docker build`,
   - при необходимости пушит образ в реестр (флаг `--push`).

Статус: идея проработана на уровне черновика; требуется выбор базового Python+Ubuntu-образа и настройка кэширования слоёв. После тестирования будет добавлена подробная инструкция в README.
