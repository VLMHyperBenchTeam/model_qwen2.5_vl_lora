# Идея

1. Каждый компонент проекта оформлен как самостоятельный `python`-пакет, который:
   - управляет зависимостями через `uv`;
   - может быть установлен стандартными инструментами (`pip`, `poetry`, `uv install`);
   - собирается при помощи `hatchling` build-backend.

2. Эти пакеты используются в проекте в **двух** режимах разработки:

   **`dev` — активная разработка**
   - пакеты подключаются из их локальных директорий (`editable install`);
   - любые изменения в исходном коде сразу видны в окружении.

   **`prod` — подготовка к релизу / CI**
   - окружение собирается из опубликованных версий, отмеченных `git tag`;
   - пакеты устанавливаются так же как из PyPI и не предполагают изменения кода.

   Переключение между этими режимами обеспечивает инструмент **`uv workspaces`**,
   автоматически создающий и изолирующий два независимых виртуальных окружения.

3. Каждый пакет расположен в отдельном репозитории на GitHub.

   Преимущества такой схемы:
   • собственная история коммитов, теги версий и ветки;
   • изоляция CI/CD-пайплайнов каждого пакета;
   • возможность открывать Pull Request-ы независимо от основного проекта.

   Чтобы при этом было удобно работать с кодом всех пакетов «под одной крышей»,
   в корневом репозитории они подключены как `git submodule`.

   Это даёт возможность:
   • выполнять привычные git-операции (`checkout`, `pull`, `log`, `tag`) прямо из корня проекта;
   • фиксировать зависимость пакета на конкретный коммит;
   • легко обновлять пакет до новой версии одной командой `git submodule update --remote`.

   По сути, submodule — это «прокси» к чужому репозиторию: код пакета не засоряет историю
   основного проекта, но при необходимости всегда под рукой.

4. Разработка и выпуск новых версий

Работать в связке `uv workspaces` + `git submodules` можно полностью вручную,
но полный цикл релиза занимает **30 минут** и требует множества однотипных действий.

Чтобы сократить рутину, был создан инструмент **`release_tool`**, который:

- автоматизирует создание коммитов, тегов и выпусков-релизов,
  оставляя при этом возможность оформить Pull Request вручную;
- формирует **diff-файлы**, которые можно передать LLM для генерации:
  - commit-сообщений в стиле **Conventional Commits**;
  - подробного **markdown-описания** релиза;
- поддерживает режим `dry-run`, позволяющий проверить все шаги без изменения репозитория.

В итоге многошаговый ручной процесс сводится к нескольким CLI-командам,
а качество сопроводительной документации повышается за счёт LLM-генерации.

5. Автоматическая сборка Docker-образа из prod-окружения

В перспективе мы хотим, чтобы после переключения проекта в режим `prod`
можно было одной CLI-командой собирать оптимизированный Docker-образ.
`uv` уже умеет фиксировать версии пакетов, поэтому задача сводится к тому,
чтобы на базе файла **prod/pyproject.toml** сформировать финальное окружение
и упаковать его в контейнер.

Зачем это нужно:
• гарантированное воспроизведение окружения на любых серверах;
• быстрый деплой через `docker pull && docker run`;
• минимальные слои за счёт кэшируемых этапов (base-образ → deps-layer → app-layer).

Как это планируется реализовать:
1. Использовать многоступенчатую сборку (`multi-stage build`)
   для разделения слоёв: `builder`, `deps`, `runtime`.
2. На этапе `deps` выполнять `uv pip sync --python /path/to/python`
   с теми же версионированными зависимостями, что и в `prod`-режиме.
3. Копировать только скомпилированные зависимости и исходный код приложения
   в финальный `runtime`-слой, оставляя кеш пакетов вне итогового образа.
4. Автоматизировать процесс в новом скрипте **`release_tool-stage7`**
   (расширение существующего пайплайна), который:
   • формирует `Dockerfile` по шаблону,
   • запускает `docker build`,
   • пушит образ в реестр (опционально, по флагу `--push`).

Статус: идея проработана на уровне черновика; требуется выбор базового образа
(Python + Ubuntu) и настройка кэширования слоёв. После тестирования
будет добавлена подробная инструкция в README.